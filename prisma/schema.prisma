generator client {
  provider = "prisma-client-js"
  engineType = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Herb {
  id                  Int       @id @default(autoincrement())
  name                String?
  commonName          String?
  latinName           String?
  slug                String?   @unique
  description         String
  metaTitle           String?
  metaDescription     String?
  heroImageUrl        String?
  cardImageUrl        String?
  galleryImages       Json?
  cautions            String?
  productFormulations Json?
  references          Json?
  traditionalUses     Json?
  products            Product[] @relation("HerbProducts")
  
  // Add variant relationships
  symptomVariants     SymptomVariant[] @relation("VariantHerbs")
  
  // Add indication relationships
  indicationTags      Indication[] @relation("HerbIndications")
}

model Symptom {
  id                  Int               @id @default(autoincrement())
  slug                String            @unique
  title               String
  description         String?
  metaTitle           String?
  metaDescription     String?
  articles            Json?
  associatedSymptoms  Json?
  cautions            String?
  references          Json?
  products            Product[]         @relation("SymptomProducts")
  
  // Add proper variant relationship
  variants            SymptomVariant[]
}

model SymptomVariant {
  id              Int      @id @default(autoincrement())
  parentSymptomId Int
  name            String   // e.g., "SAD", "Seasonal Affective Disorder"
  slug            String   @unique
  description     String?
  metaTitle       String?
  metaDescription String?
  cautions        String?
  references      Json?
  
  // Product relationships
  herbs           Herb[]       @relation("VariantHerbs")
  supplements     Supplement[] @relation("VariantSupplements")
  
  // Parent relationship
  parentSymptom   Symptom      @relation(fields: [parentSymptomId], references: [id])
  
  @@index([parentSymptomId])
}

model Supplement {
  id                  Int       @id @default(autoincrement())
  name                String
  slug                String?   @unique
  description         String
  metaTitle           String?
  metaDescription     String?
  heroImageUrl        String?
  cardImageUrl        String?
  galleryImages       Json?
  cautions            String?
  productFormulations Json?
  references          Json?
  tags                Json?
  products            Product[] @relation("SupplementProducts")
  
  // Add variant relationships
  symptomVariants     SymptomVariant[] @relation("VariantSupplements")
  
  // Add indication relationships
  indicationTags      Indication[] @relation("SupplementIndications")
}

model BlogPage {
  id         Int      @id @default(autoincrement())
  title      String
  fileUrl    String?
  uploadDate DateTime @default(now())
  adminNote  String?
  content    String?
}

model QualitySpecification {
  id                   Int    @id @default(autoincrement())
  herbSlug             String
  herbName             String
  productType          String
  requiredTerms        Json
  preferredTerms       Json
  avoidTerms           Json
  standardization      Json?
  alcoholSpecs         Json?
  dosageSpecs          Json?
  priceRange           Json
  ratingThreshold      Float
  reviewCountThreshold Int
  brandPreferences     Json?
  brandAvoid           Json?
}

model Merchant {
  id                   Int              @id @default(autoincrement())
  name                 String
  apiSource            String?
  logoUrl              String?
  websiteUrl           String?
  region               String
  createdAt            DateTime         @default(now())
  updatedAt            DateTime         @updatedAt
  defaultAffiliateRate Float?
  pendingProducts      PendingProduct[]
  products             Product[]
}

model PendingProduct {
  id             Int      @id @default(autoincrement())
  name           String
  description    String?
  merchantId     Int
  affiliateLink  String
  price          Float?
  currency       String
  region         String?
  imageUrl       String?
  qualityScore   Int?
  rawApiData     Json?
  createdAt      DateTime @default(now())
  expiresAt      DateTime
  herbId         Int?
  supplementId   Int?
  symptomId      Int?
  affiliateRate  Float?
  affiliateYield Float?
  merchant       Merchant @relation(fields: [merchantId], references: [id])
}

model Product {
  id             Int          @id @default(autoincrement())
  name           String
  description    String?
  merchantId     Int
  affiliateLink  String
  price          Float?
  currency       String
  region         String?
  imageUrl       String?
  qualityScore   Int?
  approvedBy     String?
  approvedAt     DateTime?
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  affiliateRate  Float?
  affiliateYield Float?
  merchant       Merchant     @relation(fields: [merchantId], references: [id])
  herbs          Herb[]       @relation("HerbProducts")
  supplements    Supplement[] @relation("SupplementProducts")
  symptoms       Symptom[]    @relation("SymptomProducts")
}

/*
 * INDICATION MODEL - CASCADE SYSTEM CORE
 * 
 * This model serves as the central hub for evidence-based product prioritization 
 * and the domino cascade system of product propagation.
 * 
 * CASCADE FLOW:
 * 1. PRODUCT APPROVAL: Products are approved and populate their respective herb/supplement pages
 *    - Ginkgo tincture & extract → /herbs/ginkgo-biloba (Traditional & Modern formulations)
 *    - Lion's Mane double-fermented tincture & extract → /herbs/lions-mane
 *    - L-tyrosine high-strength vegi gelcaps → /supplements/l-tyrosine
 * 
 * 2. INDICATION ASSIGNMENT: Admins assign indications to herbs/supplements
 *    - Ginkgo, Lion's Mane, L-tyrosine all assigned "Poor Memory" indication
 * 
 * 3. SYMPTOM PAGE POPULATION: Products cascade to symptom pages based on indications
 *    - All approved products from herbs/supplements with "Poor Memory" indication
 *    - Populate /symptoms/poor-memory recommended products section
 * 
 * EVIDENCE SCORING:
 * - Evidence scores are stored on the relationship tables (HerbIndication, SupplementIndication)
 * - Same herb can have different evidence scores for different indications
 * - Example: Ginkgo + Memory (evidence: 90), Ginkgo + Anxiety (evidence: 60)
 * - Controls product priority and order on symptom pages
 * - Prevents overpopulation by limiting products per symptom based on evidence scores
 * 
 * FUTURE CASCADE INTEGRATION:
 * - When products are approved, system queries "which indications does this herb/supplement have"
 * - Automatically cascades approved products to all related symptom pages
 * - Evidence scores determine product order and visibility on symptom pages
 */

model Indication {
  id          Int         @id @default(autoincrement())
  name        String      @unique
  slug        String      @unique
  description String?
  color       String      @default("blue")
  herbs       Herb[]      @relation("HerbIndications")
  supplements Supplement[] @relation("SupplementIndications")
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
}
